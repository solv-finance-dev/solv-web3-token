{"version":3,"file":"web3-token.cjs.production.min.js","sources":["../src/libs/timespan.ts","../src/libs/sign/index.ts","../src/libs/verify/decrypter.ts","../src/libs/verify/index.ts","../src/index.ts"],"sourcesContent":["\nimport ms from 'ms'\n\nexport const timeSpan = (val: string | number) => {\n\n    const err_str = '\"expires_in\" argument should be a number of milliseconds or a string representing a timespan eg: \"1d\", \"20h\", 60';\n\n    if (typeof val === 'string') {\n        const milliseconds = ms(val);\n\n        if (typeof milliseconds === 'undefined') {\n            throw new Error(err_str)\n        }\n\n        return new Date(Date.now() + milliseconds);\n    }\n    else if (typeof val === 'number') {\n        return new Date(Date.now() + val);\n    }\n    else {\n        throw new Error(err_str)\n    }\n};","import Base64 from 'base-64';\nimport { timeSpan } from '../timespan';\nimport isValidDomain from 'is-valid-domain';\nimport { SignBody, Signer, SignOpts } from '../interfaces';\n\nfunction isURL(str: string): boolean {\n  try {\n    new URL(str);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const sign = async (signer: Signer, opts: string | SignOpts = '1d'): Promise<string> => {\n  const params =\n    typeof opts === 'string'\n      ? {\n          expires_in: opts,\n        }\n      : opts;\n\n  validateParams(params);\n\n  const body = processParams(params);\n\n  const msg = buildMessage(body);\n\n  const signature = await signer(msg);\n\n  if (typeof signature !== 'string') {\n    throw new Error('\"signer\" argument should be a function that returns a signature string (Promise<string>)');\n  }\n\n  const token = Base64.encode(\n    JSON.stringify({\n      signature,\n      body: msg,\n    })\n  );\n\n  return token;\n};\n\nconst isValidString = (val: string): boolean => {\n  return typeof val === 'string' && !!val.length;\n};\n\nconst validateParams = (params: SignOpts) => {\n  // for (const key in params) {\n  //     if (typeof (params as any)[key] === 'string' && /\\n/.test((params as any)[key])) {\n  //         throw new Error(`\"${key}\" option cannot have LF (\\\\n)`);\n  //     }\n  // }\n\n  if (params.domain && (!isValidString(params.domain) || !isValidDomain(params.domain))) {\n    throw new Error('Invalid domain format (must be example.com)');\n  }\n\n  if (params.uri !== undefined && (!isValidString(params.uri) || !isURL(params.uri))) {\n    throw new Error('Invalid uri format (must be https://example.com/login)');\n  }\n\n  if (params.chain_id !== undefined && (typeof params.chain_id !== 'number' || isNaN(params.chain_id))) {\n    throw new Error('chain_id must be an int');\n  }\n\n  if (params.expiration_time && !(params.expiration_time instanceof Date)) {\n    throw new Error('expiration_time must be an instance of Date');\n  }\n\n  if (params.not_before && !(params.not_before instanceof Date)) {\n    throw new Error('not_before must be an instance of Date');\n  }\n};\n\nconst processParams = (params: SignOpts): SignBody => {\n  const body = {} as SignBody;\n\n  body.web3_token_version = '2';\n  body.issued_at = new Date();\n\n  if (params.expiration_time) {\n    body.expiration_time = new Date(params.expiration_time);\n  }\n\n  if (params.expires_in && !params.expiration_time) {\n    body.expiration_time = timeSpan(params.expires_in);\n  }\n\n  if (!params.expires_in && !params.expiration_time) {\n    body.expiration_time = timeSpan('1d');\n  }\n\n  if (params.not_before) {\n    body.not_before = new Date(params.not_before);\n  }\n\n  if (params.chain_id) {\n    body.chain_id = parseInt(String(params.chain_id));\n  }\n\n  if (!params.uri && typeof window !== 'undefined' && window?.location?.href) {\n    body.uri = window.location.href;\n  }\n\n  if (!params.nonce) {\n    body.nonce = parseInt(String(Math.random() * 99999999));\n  } else {\n    body.nonce = params.nonce;\n  }\n\n  if (params.domain) {\n    body.domain = params.domain;\n  }\n\n  if (params.statement) {\n    body.statement = params.statement;\n  }\n\n  return body;\n};\n\nconst buildMessage = (params: SignBody): string => {\n  const message: string[] = [];\n\n  if (params.domain) {\n    message.push(`${params.domain} wants you to sign in with your Ethereum account.`);\n    message.push('');\n  }\n\n  if (params.statement) {\n    message.push(params.statement);\n    message.push('');\n  }\n\n  const param_labels = {\n    URI: params.uri,\n    'Web3 Token Version': params.web3_token_version,\n    'Chain ID': params.chain_id,\n    Nonce: params.nonce,\n    'Issued At': params.issued_at.toISOString(),\n    'Expiration Time': params.expiration_time.toISOString(),\n    'Not Before': params.not_before ? params.not_before.toISOString() : undefined,\n    'Request ID': params.request_id,\n  };\n\n  for (const label in param_labels) {\n    if ((param_labels as any)[label] !== undefined) {\n      // @ts-ignore\n      message.push(`${label}: ${(param_labels as any)[label]}`);\n    }\n  }\n\n  return message.join('\\n');\n};\n","import Base64 from 'base-64'\nimport {\n    hashPersonalMessage,\n    toBuffer,\n    fromRpcSig,\n    ecrecover,\n    publicToAddress,\n    bufferToHex\n} from 'ethereumjs-util';\nimport toHex from 'to-hex';\nimport { DecrypterResult } from '../interfaces';\n\nconst getVersion = (body: string): number => {\n    // @ts-ignore\n    const [str] = body.match(/Web3[\\s-]+Token[\\s-]+Version: \\d/);\n\n    return Number(str.replace(' ', '').split(':')[1]);\n}\n\nexport const decrypt = (token: string): DecrypterResult => {\n    if (!token || !token.length) {\n        throw new Error('Token required.')\n    }\n    const base64_decoded = Base64.decode(token);\n    if (!base64_decoded || !base64_decoded.length) {\n        throw new Error('Token malformed (must be base64 encoded)')\n    }\n\n    let body: string, signature: string;\n\n    try {\n        ({ body, signature } = JSON.parse(base64_decoded));\n    } catch (error) {\n        throw new Error('Token malformed (unparsable JSON)')\n    }\n\n    if (!body || !body.length) {\n        throw new Error('Token malformed (empty message)')\n    }\n    console.log('body', body);\n    if (!signature || !signature.length) {\n        throw new Error('Token malformed (empty signature)')\n    }\n\n    const msgBuffer = toBuffer('0x' + toHex(body));\n    const msgHash = hashPersonalMessage(msgBuffer);\n    const signatureBuffer = toBuffer(signature);\n    const signatureParams = fromRpcSig(signatureBuffer as any);\n\n\n    const publicKey = ecrecover(\n        msgHash,\n        signatureParams.v,\n        signatureParams.r,\n        signatureParams.s\n    );\n    const addressBuffer = publicToAddress(publicKey);\n    const userAddress = bufferToHex(addressBuffer).toLowerCase();\n    const address = userAddress;\n\n    const version = getVersion(body);\n\n    return {\n        version,\n        address,\n        body,\n        signature\n    }\n}\n\nexport const erc1271Decrypt = (token: string, safeMessageHash: string): DecrypterResult => {\n    if (!token || !token.length) {\n        throw new Error('Token required.')\n    }\n    const base64_decoded = Base64.decode(token);\n    if (!base64_decoded || !base64_decoded.length) {\n        throw new Error('Token malformed (must be base64 encoded)')\n    }\n\n    let body: string, signature: string;\n\n    try {\n        ({ body, signature } = JSON.parse(base64_decoded));\n    } catch (error) {\n        throw new Error('Token malformed (unparsable JSON)')\n    }\n\n    if (!body || !body.length) {\n        throw new Error('Token malformed (empty message)')\n    }\n    console.log('body', body);\n    if (!signature || !signature.length) {\n        throw new Error('Token malformed (empty signature)')\n    }\n\n    const msgHash = toBuffer(safeMessageHash);\n    const signatureBuffer = toBuffer(signature);\n\n    const v: number = Number(signatureBuffer[64]);\n    const r: any = signatureBuffer.slice(0, 32);\n    const s: any = signatureBuffer.slice(32, 64);\n\n    const publicKey = ecrecover(\n        msgHash,\n        v,\n        r,\n        s\n    );\n    const addressBuffer = publicToAddress(publicKey);\n    const userAddress = bufferToHex(addressBuffer).toLowerCase();\n    const address = userAddress;\n\n    const version = getVersion(body);\n\n    return {\n        version,\n        address,\n        body,\n        signature\n    }\n}","import parseAsHeaders from 'parse-headers';\nimport { DecryptedBody, MessageSections, VerifyOpts } from '../interfaces';\nimport { decrypt, erc1271Decrypt } from './decrypter';\n\nconst getDomain = (sections: MessageSections): string | undefined => {\n    if (/ wants you to sign in with your Ethereum account\\.$/.test(sections[0][0])) {\n        return sections[0][0].replace(\" wants you to sign in with your Ethereum account.\", '').trim();\n    }\n\n    return undefined;\n}\n\nconst splitSections = (lines: string[]): MessageSections => {\n\n    const sections: MessageSections = [[]];\n    let section_number = 0;\n    for (const line of lines) {\n        sections[section_number].push(line)\n        if (line === '') {\n            section_number++;\n            sections.push([])\n        }\n    }\n\n    return sections;\n}\n\nconst getStatement = (sections: MessageSections): string | undefined => {\n\n    if (sections.length === 2) {\n        const has_domain = !!getDomain(sections);\n\n        if (!has_domain) {\n            return sections[0][0]\n        }\n    }\n    else if (sections.length === 3) {\n        return sections[1][0]\n    }\n\n    return undefined;\n}\n\nconst parseBody = (lines: string[]): DecryptedBody => {\n\n    const sections = splitSections(lines);\n    const main_section = sections[sections.length - 1].join('\\n')\n    const parsed_body = parseAsHeaders(main_section) as any;\n\n    for (const key in parsed_body) {\n        const new_key = key.replace(/ /g, '-');\n        parsed_body[new_key] = parsed_body[key];\n        if (new_key !== key) {\n            delete parsed_body[key];\n        }\n    }\n\n    const domain = getDomain(sections);\n    const statement = getStatement(sections);\n\n    if (typeof domain !== 'undefined') {\n        parsed_body.domain = domain\n    }\n\n    if (typeof statement !== 'undefined') {\n        parsed_body.statement = statement\n    }\n\n    if (\n        typeof parsed_body['issued-at'] === 'undefined' ||\n        typeof parsed_body['expiration-time'] === 'undefined' ||\n        typeof parsed_body['web3-token-version'] === 'undefined'\n    ) {\n        throw new Error('Decrypted body is damaged');\n    }\n\n    return parsed_body;\n}\n\nexport const verify = (token: string, opts: VerifyOpts = {\n    isERC1271: false\n}) => {\n\n    const { version, address, body } = opts.isERC1271 ? erc1271Decrypt(token, opts?.safeMessageHash ?? '') : decrypt(token);\n\n    if (version === 1) {\n        throw new Error('Tokens version 1 are not supported by the current version of module')\n    }\n\n    const lines = body.split('\\n');\n    const parsed_body = parseBody(lines);\n\n    if (new Date(parsed_body['expiration-time']) < new Date()) {\n        throw new Error('Token expired')\n    }\n\n    if (parsed_body['not-before'] && new Date(parsed_body['not-before']) > new Date()) {\n        throw new Error('It\\'s not yet time to use the token')\n    }\n\n    if (opts.domain && opts.domain !== parsed_body.domain) {\n        throw new Error('Inappropriate token domain')\n    }\n\n    return { address, body: parsed_body }\n}","import { sign } from './libs/sign';\nimport { verify } from './libs/verify';\n\nconst SolvWeb3Token = {\n    sign,\n    verify,\n}\n\nexport default SolvWeb3Token;\nexport { sign, verify };"],"names":["timeSpan","val","err_str","milliseconds","ms","Error","Date","now","sign","signer","opts","validateParams","params","expires_in","body","processParams","msg","buildMessage","_context","signature","token","Base64","encode","JSON","stringify","isValidString","length","domain","isValidDomain","undefined","uri","str","URL","isURL","chain_id","isNaN","expiration_time","not_before","issued_at","parseInt","String","window","_window","location","_window$location","href","nonce","Math","random","statement","message","push","param_labels","URI","Web3 Token Version","web3_token_version","Chain ID","Nonce","Issued At","toISOString","Expiration Time","Not Before","Request ID","request_id","label","join","getVersion","match","Number","replace","split","getDomain","sections","test","trim","verify","isERC1271","safeMessageHash","base64_decoded","decode","parse","error","console","log","msgHash","toBuffer","signatureBuffer","v","r","slice","s","publicKey","ecrecover","addressBuffer","publicToAddress","address","bufferToHex","toLowerCase","version","erc1271Decrypt","_opts","msgBuffer","toHex","hashPersonalMessage","signatureParams","fromRpcSig","decrypt","parsed_body","lines","section_number","line","splitSections","main_section","parseAsHeaders","key","new_key","getStatement","parseBody"],"mappings":"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"}