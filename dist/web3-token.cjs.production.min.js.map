{"version":3,"file":"web3-token.cjs.production.min.js","sources":["../src/libs/timespan.ts","../src/libs/sign/index.ts","../src/libs/verify/index.ts","../src/libs/verify/decrypter.ts","../src/index.ts"],"sourcesContent":["\nimport ms from 'ms'\n\nexport const timeSpan = (val: string | number) => {\n\n    const err_str = '\"expires_in\" argument should be a number of milliseconds or a string representing a timespan eg: \"1d\", \"20h\", 60';\n\n    if (typeof val === 'string') {\n        const milliseconds = ms(val);\n\n        if (typeof milliseconds === 'undefined') {\n            throw new Error(err_str)\n        }\n\n        return new Date(Date.now() + milliseconds);\n    }\n    else if (typeof val === 'number') {\n        return new Date(Date.now() + val);\n    }\n    else {\n        throw new Error(err_str)\n    }\n};","import Base64 from 'base-64';\nimport { timeSpan } from '../timespan';\nimport isValidDomain from 'is-valid-domain';\nimport { SignBody, Signer, SignOpts } from '../interfaces';\n\nfunction isURL(str: string): boolean {\n    try {\n        new URL(str);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport const sign = async (\n    signer: Signer,\n    opts: string | SignOpts = '1d'\n): Promise<string> => {\n\n    const params = typeof opts === 'string' ? {\n        expires_in: opts\n    } : opts;\n\n    validateParams(params);\n\n    const body = processParams(params);\n\n    const msg = buildMessage(body);\n\n    const signature = await signer(msg);\n\n    if (typeof signature !== 'string') {\n        throw new Error('\"signer\" argument should be a function that returns a signature string (Promise<string>)')\n    }\n\n    const token = Base64.encode(JSON.stringify({\n        signature,\n        body: msg,\n    }));\n\n    return token;\n}\n\nconst isValidString = (val: string): boolean => {\n    return typeof val === 'string' && !!val.length;\n}\n\nconst validateParams = (params: SignOpts) => {\n\n    for (const key in params) {\n        if (typeof (params as any)[key] === 'string' && /\\n/.test((params as any)[key])) {\n            throw new Error(`\"${key}\" option cannot have LF (\\\\n)`);\n        }\n    }\n\n    if (params.domain && (!isValidString(params.domain) || !isValidDomain(params.domain))) {\n        throw new Error('Invalid domain format (must be example.com)');\n    }\n\n    if (params.uri !== undefined && (!isValidString(params.uri) || !isURL(params.uri))) {\n        throw new Error('Invalid uri format (must be https://example.com/login)');\n    }\n\n    if (params.chain_id !== undefined && (typeof params.chain_id !== 'number' || isNaN(params.chain_id))) {\n        throw new Error('chain_id must be an int');\n    }\n\n    if (params.expiration_time && !(params.expiration_time instanceof Date)) {\n        throw new Error('expiration_time must be an instance of Date');\n    }\n\n    if (params.not_before && !(params.not_before instanceof Date)) {\n        throw new Error('not_before must be an instance of Date');\n    }\n};\n\nconst processParams = (params: SignOpts): SignBody => {\n\n    const body = {} as SignBody;\n\n    body.web3_token_version = '2'\n    body.issued_at = new Date();\n\n    if (params.expiration_time) {\n        body.expiration_time = new Date(params.expiration_time);\n    }\n\n    if (params.expires_in && !params.expiration_time) {\n        body.expiration_time = timeSpan(params.expires_in);\n    }\n\n    if (!params.expires_in && !params.expiration_time) {\n        body.expiration_time = timeSpan('1d');\n    }\n\n    if (params.not_before) {\n        body.not_before = new Date(params.not_before);\n    }\n\n    if (params.chain_id) {\n        body.chain_id = parseInt(String(params.chain_id));\n    }\n\n    if (!params.uri && typeof window !== 'undefined' && window?.location?.href) {\n        body.uri = window.location.href;\n    }\n\n    if (!params.nonce) {\n        body.nonce = parseInt(String(Math.random() * 99999999));\n    }\n    else {\n        body.nonce = params.nonce;\n    }\n\n    if (params.domain) {\n        body.domain = params.domain;\n    }\n\n    if (params.statement) {\n        body.statement = params.statement;\n    }\n\n    return body;\n};\n\nconst buildMessage = (params: SignBody): string => {\n    const message: string[] = [];\n\n    if (params.domain) {\n        message.push(`${params.domain} wants you to sign in with your Ethereum account.`);\n        message.push('');\n    }\n\n    if (params.statement) {\n        message.push(params.statement);\n        message.push('');\n    }\n\n    const param_labels = {\n        'URI': params.uri,\n        'Web3 Token Version': params.web3_token_version,\n        'Chain ID': params.chain_id,\n        'Nonce': params.nonce,\n        'Issued At': params.issued_at.toISOString(),\n        'Expiration Time': params.expiration_time.toISOString(),\n        'Not Before': params.not_before ? params.not_before.toISOString() : undefined,\n        'Request ID': params.request_id,\n    };\n\n    for (const label in param_labels) {\n\n        if ((param_labels as any)[label] !== undefined) {\n\n            // @ts-ignore\n            message.push(`${label}: ${(param_labels as any)[label]}`)\n        }\n    }\n\n    return message.join('\\n');\n};\n","import parseAsHeaders from 'parse-headers';\nimport { DecryptedBody, MessageSections, VerifyOpts } from '../interfaces';\nimport { decrypt } from './decrypter';\n\nconst getDomain = (sections: MessageSections): string | undefined => {\n    if (/ wants you to sign in with your Ethereum account\\.$/.test(sections[0][0])) {\n        return sections[0][0].replace(\" wants you to sign in with your Ethereum account.\", '').trim();\n    }\n\n    return undefined;\n}\n\nconst splitSections = (lines: string[]): MessageSections => {\n\n    const sections: MessageSections = [[]];\n    let section_number = 0;\n    for (const line of lines) {\n        sections[section_number].push(line)\n        if (line === '') {\n            section_number++;\n            sections.push([])\n        }\n    }\n\n    return sections;\n}\n\nconst getStatement = (sections: MessageSections): string | undefined => {\n\n    if (sections.length === 2) {\n        const has_domain = !!getDomain(sections);\n\n        if (!has_domain) {\n            return sections[0][0]\n        }\n    }\n    else if (sections.length === 3) {\n        return sections[1][0]\n    }\n\n    return undefined;\n}\n\nconst parseBody = (lines: string[]): DecryptedBody => {\n\n    const sections = splitSections(lines);\n    const main_section = sections[sections.length - 1].join('\\n')\n    const parsed_body = parseAsHeaders(main_section) as any;\n\n    for (const key in parsed_body) {\n        const new_key = key.replace(/ /g, '-');\n        parsed_body[new_key] = parsed_body[key];\n        if (new_key !== key) {\n            delete parsed_body[key];\n        }\n    }\n\n    const domain = getDomain(sections);\n    const statement = getStatement(sections);\n\n    if (typeof domain !== 'undefined') {\n        parsed_body.domain = domain\n    }\n\n    if (typeof statement !== 'undefined') {\n        parsed_body.statement = statement\n    }\n\n    if (\n        typeof parsed_body['issued-at'] === 'undefined' ||\n        typeof parsed_body['expiration-time'] === 'undefined' ||\n        typeof parsed_body['web3-token-version'] === 'undefined'\n    ) {\n        throw new Error('Decrypted body is damaged');\n    }\n\n    return parsed_body;\n}\n\nexport const verify = (token: string, opts: VerifyOpts = {}) => {\n\n    const { version, address, body } = decrypt(token);\n\n    if (version === 1) {\n        throw new Error('Tokens version 1 are not supported by the current version of module')\n    }\n\n    const lines = body.split('\\n');\n    const parsed_body = parseBody(lines);\n\n    if (new Date(parsed_body['expiration-time']) < new Date()) {\n        throw new Error('Token expired')\n    }\n\n    if (parsed_body['not-before'] && new Date(parsed_body['not-before']) > new Date()) {\n        throw new Error('It\\'s not yet time to use the token')\n    }\n\n    if (opts.domain && opts.domain !== parsed_body.domain) {\n        throw new Error('Inappropriate token domain')\n    }\n\n    return { address, body: parsed_body }\n}","import Base64 from 'base-64'\nimport {\n    hashPersonalMessage,\n    toBuffer,\n    fromRpcSig,\n    ecrecover,\n    publicToAddress,\n    bufferToHex\n} from 'ethereumjs-util';\nimport toHex from 'to-hex';\nimport { DecrypterResult } from '../interfaces';\n\nconst getVersion = (body: string): number => {\n    // @ts-ignore\n    const [str] = body.match(/Web3[\\s-]+Token[\\s-]+Version: \\d/);\n\n    return Number(str.replace(' ', '').split(':')[1]);\n}\n\nexport const decrypt = (token: string): DecrypterResult => {\n    if (!token || !token.length) {\n        throw new Error('Token required.')\n    }\n\n    const base64_decoded = Base64.decode(token);\n\n    if (!base64_decoded || !base64_decoded.length) {\n        throw new Error('Token malformed (must be base64 encoded)')\n    }\n\n    let body: string, signature: string;\n\n    try {\n        ({ body, signature } = JSON.parse(base64_decoded));\n    } catch (error) {\n        throw new Error('Token malformed (unparsable JSON)')\n    }\n\n    if (!body || !body.length) {\n        throw new Error('Token malformed (empty message)')\n    }\n\n    if (!signature || !signature.length) {\n        throw new Error('Token malformed (empty signature)')\n    }\n\n    const msgBuffer = toBuffer('0x' + toHex(body));\n    const msgHash = hashPersonalMessage(msgBuffer);\n    const signatureBuffer = toBuffer(signature);\n    const signatureParams = fromRpcSig(signatureBuffer as any);\n\n    const publicKey = ecrecover(\n        msgHash,\n        signatureParams.v,\n        signatureParams.r,\n        signatureParams.s\n    );\n    const addressBuffer = publicToAddress(publicKey);\n    const address = bufferToHex(addressBuffer).toLowerCase();\n\n    const version = getVersion(body);\n\n    return {\n        version,\n        address,\n        body,\n        signature\n    }\n}","import { sign } from './libs/sign';\nimport { verify } from './libs/verify';\n\nconst SolvWeb3Token = {\n    sign,\n    verify,\n}\n\nexport default SolvWeb3Token;\nexport { sign, verify };"],"names":["timeSpan","val","err_str","milliseconds","ms","Error","Date","now","sign","signer","opts","validateParams","params","expires_in","body","processParams","msg","buildMessage","_context","signature","token","Base64","encode","JSON","stringify","isValidString","length","key","test","domain","isValidDomain","undefined","uri","str","URL","isURL","chain_id","isNaN","expiration_time","not_before","issued_at","parseInt","String","window","_window","location","_window$location","href","nonce","Math","random","statement","message","push","param_labels","URI","Web3 Token Version","web3_token_version","Chain ID","Nonce","Issued At","toISOString","Expiration Time","Not Before","Request ID","request_id","label","join","getDomain","sections","replace","trim","verify","base64_decoded","decode","parse","error","msgBuffer","toBuffer","toHex","msgHash","hashPersonalMessage","signatureBuffer","signatureParams","fromRpcSig","publicKey","ecrecover","v","r","s","addressBuffer","publicToAddress","address","bufferToHex","toLowerCase","version","match","Number","split","getVersion","decrypt","parsed_body","lines","section_number","line","splitSections","main_section","parseAsHeaders","new_key","getStatement","parseBody"],"mappings":"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"}