{"version":3,"file":"web3-token.cjs.production.min.js","sources":["../src/libs/timespan.ts","../src/libs/sign/index.ts","../src/libs/verify/index.ts","../src/libs/verify/decrypter.ts","../src/index.ts"],"sourcesContent":["\nimport ms from 'ms'\n\nexport const timeSpan = (val: string | number) => {\n\n    const err_str = '\"expires_in\" argument should be a number of milliseconds or a string representing a timespan eg: \"1d\", \"20h\", 60';\n\n    if (typeof val === 'string') {\n        const milliseconds = ms(val);\n\n        if (typeof milliseconds === 'undefined') {\n            throw new Error(err_str)\n        }\n\n        return new Date(Date.now() + milliseconds);\n    }\n    else if (typeof val === 'number') {\n        return new Date(Date.now() + val);\n    }\n    else {\n        throw new Error(err_str)\n    }\n};","import Base64 from 'base-64';\nimport { timeSpan } from '../timespan';\nimport isValidDomain from 'is-valid-domain';\nimport { SignBody, Signer, SignOpts } from '../interfaces';\n\nfunction isURL(str: string): boolean {\n  try {\n    new URL(str);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const sign = async (signer: Signer, opts: string | SignOpts = '1d'): Promise<string> => {\n  const params =\n    typeof opts === 'string'\n      ? {\n          expires_in: opts,\n        }\n      : opts;\n\n  validateParams(params);\n\n  const body = processParams(params);\n\n  const msg = buildMessage(body);\n\n  const signature = await signer(msg);\n\n  if (typeof signature !== 'string') {\n    throw new Error('\"signer\" argument should be a function that returns a signature string (Promise<string>)');\n  }\n\n  const token = Base64.encode(\n    JSON.stringify({\n      signature,\n      body: msg,\n    })\n  );\n\n  return token;\n};\n\nconst isValidString = (val: string): boolean => {\n  return typeof val === 'string' && !!val.length;\n};\n\nconst validateParams = (params: SignOpts) => {\n  // for (const key in params) {\n  //     if (typeof (params as any)[key] === 'string' && /\\n/.test((params as any)[key])) {\n  //         throw new Error(`\"${key}\" option cannot have LF (\\\\n)`);\n  //     }\n  // }\n\n  if (params.domain && (!isValidString(params.domain) || !isValidDomain(params.domain))) {\n    throw new Error('Invalid domain format (must be example.com)');\n  }\n\n  if (params.uri !== undefined && (!isValidString(params.uri) || !isURL(params.uri))) {\n    throw new Error('Invalid uri format (must be https://example.com/login)');\n  }\n\n  if (params.chain_id !== undefined && (typeof params.chain_id !== 'number' || isNaN(params.chain_id))) {\n    throw new Error('chain_id must be an int');\n  }\n\n  if (params.expiration_time && !(params.expiration_time instanceof Date)) {\n    throw new Error('expiration_time must be an instance of Date');\n  }\n\n  if (params.not_before && !(params.not_before instanceof Date)) {\n    throw new Error('not_before must be an instance of Date');\n  }\n};\n\nconst processParams = (params: SignOpts): SignBody => {\n  const body = {} as SignBody;\n\n  body.web3_token_version = '2';\n  body.issued_at = new Date();\n\n  if (params.expiration_time) {\n    body.expiration_time = new Date(params.expiration_time);\n  }\n\n  if (params.expires_in && !params.expiration_time) {\n    body.expiration_time = timeSpan(params.expires_in);\n  }\n\n  if (!params.expires_in && !params.expiration_time) {\n    body.expiration_time = timeSpan('1d');\n  }\n\n  if (params.not_before) {\n    body.not_before = new Date(params.not_before);\n  }\n\n  if (params.chain_id) {\n    body.chain_id = parseInt(String(params.chain_id));\n  }\n\n  if (!params.uri && typeof window !== 'undefined' && window?.location?.href) {\n    body.uri = window.location.href;\n  }\n\n  if (!params.nonce) {\n    body.nonce = parseInt(String(Math.random() * 99999999));\n  } else {\n    body.nonce = params.nonce;\n  }\n\n  if (params.domain) {\n    body.domain = params.domain;\n  }\n\n  if (params.statement) {\n    body.statement = params.statement;\n  }\n\n  return body;\n};\n\nconst buildMessage = (params: SignBody): string => {\n  const message: string[] = [];\n\n  if (params.domain) {\n    message.push(`${params.domain} wants you to sign in with your Ethereum account.`);\n    message.push('');\n  }\n\n  if (params.statement) {\n    message.push(params.statement);\n    message.push('');\n  }\n\n  const param_labels = {\n    URI: params.uri,\n    'Web3 Token Version': params.web3_token_version,\n    'Chain ID': params.chain_id,\n    Nonce: params.nonce,\n    'Issued At': params.issued_at.toISOString(),\n    'Expiration Time': params.expiration_time.toISOString(),\n    'Not Before': params.not_before ? params.not_before.toISOString() : undefined,\n    'Request ID': params.request_id,\n  };\n\n  for (const label in param_labels) {\n    if ((param_labels as any)[label] !== undefined) {\n      // @ts-ignore\n      message.push(`${label}: ${(param_labels as any)[label]}`);\n    }\n  }\n\n  return message.join('\\n');\n};\n","import parseAsHeaders from 'parse-headers';\nimport { DecryptedBody, MessageSections, VerifyOpts } from '../interfaces';\nimport { decrypt } from './decrypter';\n\nconst getDomain = (sections: MessageSections): string | undefined => {\n    if (/ wants you to sign in with your Ethereum account\\.$/.test(sections[0][0])) {\n        return sections[0][0].replace(\" wants you to sign in with your Ethereum account.\", '').trim();\n    }\n\n    return undefined;\n}\n\nconst splitSections = (lines: string[]): MessageSections => {\n\n    const sections: MessageSections = [[]];\n    let section_number = 0;\n    for (const line of lines) {\n        sections[section_number].push(line)\n        if (line === '') {\n            section_number++;\n            sections.push([])\n        }\n    }\n\n    return sections;\n}\n\nconst getStatement = (sections: MessageSections): string | undefined => {\n\n    if (sections.length === 2) {\n        const has_domain = !!getDomain(sections);\n\n        if (!has_domain) {\n            return sections[0][0]\n        }\n    }\n    else if (sections.length === 3) {\n        return sections[1][0]\n    }\n\n    return undefined;\n}\n\nconst parseBody = (lines: string[]): DecryptedBody => {\n\n    const sections = splitSections(lines);\n    const main_section = sections[sections.length - 1].join('\\n')\n    const parsed_body = parseAsHeaders(main_section) as any;\n\n    for (const key in parsed_body) {\n        const new_key = key.replace(/ /g, '-');\n        parsed_body[new_key] = parsed_body[key];\n        if (new_key !== key) {\n            delete parsed_body[key];\n        }\n    }\n\n    const domain = getDomain(sections);\n    const statement = getStatement(sections);\n\n    if (typeof domain !== 'undefined') {\n        parsed_body.domain = domain\n    }\n\n    if (typeof statement !== 'undefined') {\n        parsed_body.statement = statement\n    }\n\n    if (\n        typeof parsed_body['issued-at'] === 'undefined' ||\n        typeof parsed_body['expiration-time'] === 'undefined' ||\n        typeof parsed_body['web3-token-version'] === 'undefined'\n    ) {\n        throw new Error('Decrypted body is damaged');\n    }\n\n    return parsed_body;\n}\n\nexport const verify = (token: string, opts: VerifyOpts = {\n    address: ''\n}) => {\n\n    const { version, address, body } = decrypt(token, opts.address);\n\n    if (version === 1) {\n        throw new Error('Tokens version 1 are not supported by the current version of module')\n    }\n\n    const lines = body.split('\\n');\n    const parsed_body = parseBody(lines);\n\n    if (new Date(parsed_body['expiration-time']) < new Date()) {\n        throw new Error('Token expired')\n    }\n\n    if (parsed_body['not-before'] && new Date(parsed_body['not-before']) > new Date()) {\n        throw new Error('It\\'s not yet time to use the token')\n    }\n\n    if (opts.domain && opts.domain !== parsed_body.domain) {\n        throw new Error('Inappropriate token domain')\n    }\n\n    return { address, body: parsed_body }\n}","import Base64 from 'base-64'\nimport {\n    hashPersonalMessage,\n    toBuffer,\n    fromRpcSig,\n    ecrecover,\n    publicToAddress,\n    bufferToHex,\n    isValidAddress\n} from 'ethereumjs-util';\nimport toHex from 'to-hex';\nimport { DecrypterResult } from '../interfaces';\n\nconst getVersion = (body: string): number => {\n    // @ts-ignore\n    const [str] = body.match(/Web3[\\s-]+Token[\\s-]+Version: \\d/);\n\n    return Number(str.replace(' ', '').split(':')[1]);\n}\n\nexport const decrypt = (token: string, contractSignerAddress: string = ''): DecrypterResult => {\n    if (!token || !token.length) {\n        throw new Error('Token required.')\n    }\n\n    const base64_decoded = Base64.decode(token);\n\n    if (!base64_decoded || !base64_decoded.length) {\n        throw new Error('Token malformed (must be base64 encoded)')\n    }\n\n    let body: string, signature: string;\n\n    try {\n        ({ body, signature } = JSON.parse(base64_decoded));\n    } catch (error) {\n        throw new Error('Token malformed (unparsable JSON)')\n    }\n\n    if (!body || !body.length) {\n        throw new Error('Token malformed (empty message)')\n    }\n\n    if (!signature || !signature.length) {\n        throw new Error('Token malformed (empty signature)')\n    }\n\n    const msgBuffer = toBuffer('0x' + toHex(body));\n    const msgHash = hashPersonalMessage(msgBuffer);\n    const signatureBuffer = toBuffer(signature);\n    const signatureParams = fromRpcSig(signatureBuffer as any);\n\n    let address: string = contractSignerAddress;\n    if (!isValidAddress(contractSignerAddress)) {\n        const publicKey = ecrecover(\n            msgHash,\n            signatureParams.v,\n            signatureParams.r,\n            signatureParams.s\n        );\n        const addressBuffer = publicToAddress(publicKey);\n        const userAddress = bufferToHex(addressBuffer).toLowerCase();\n        address = userAddress;\n    }\n    const version = getVersion(body);\n\n    return {\n        version,\n        address,\n        body,\n        signature\n    }\n}","import { sign } from './libs/sign';\nimport { verify } from './libs/verify';\n\nconst SolvWeb3Token = {\n    sign,\n    verify,\n}\n\nexport default SolvWeb3Token;\nexport { sign, verify };"],"names":["timeSpan","val","err_str","milliseconds","ms","Error","Date","now","sign","signer","opts","validateParams","params","expires_in","body","processParams","msg","buildMessage","_context","signature","token","Base64","encode","JSON","stringify","isValidString","length","domain","isValidDomain","undefined","uri","str","URL","isURL","chain_id","isNaN","expiration_time","not_before","issued_at","parseInt","String","window","_window","location","_window$location","href","nonce","Math","random","statement","message","push","param_labels","URI","Web3 Token Version","web3_token_version","Chain ID","Nonce","Issued At","toISOString","Expiration Time","Not Before","Request ID","request_id","label","join","getDomain","sections","test","replace","trim","verify","address","contractSignerAddress","base64_decoded","decode","parse","error","msgBuffer","toBuffer","toHex","msgHash","hashPersonalMessage","signatureBuffer","signatureParams","fromRpcSig","isValidAddress","publicKey","ecrecover","v","r","s","addressBuffer","publicToAddress","bufferToHex","toLowerCase","version","match","Number","split","getVersion","decrypt","parsed_body","lines","section_number","line","splitSections","main_section","parseAsHeaders","key","new_key","getStatement","parseBody"],"mappings":"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"}